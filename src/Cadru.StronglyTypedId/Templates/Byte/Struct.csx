//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Cadru.StronglyTypedId source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
{{ if NullableEnabled }}#nullable restore{{ end }}

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
{{ for usingDirective in UsingDirectives ~}}
using {{ usingDirective }};
{{ end ~}}

namespace {{ ContainingNamespace }}
{
    /// <inheritdoc />
    [System.CodeDom.Compiler.GeneratedCode("Cadru.StronglyTypedId", "{{ AssemblyVersion }}")]
    [System.Diagnostics.DebuggerDisplay("{ToDebugString()}")]
    {{~ if ConverterAttributes[0] == true ~}}
    [System.ComponentModel.TypeConverter(typeof({{ TypeName }}TypeConverter))]
    {{~ end ~}}
    {{~ if ConverterAttributes[1] == true ~}}
    [Newtonsoft.Json.JsonConverter(typeof({{ TypeName }}NewtonsoftJsonConverter))]
    {{~ end ~}}
    {{~ if ConverterAttributes[2] == true ~}}
    [System.Text.Json.Serialization.JsonConverter(typeof({{ TypeName }}JsonConverter))]
    {{~ end ~}}
    readonly partial struct {{ TypeName }} : IComparable, IComparable<{{ TypeName }}>, IEquatable<{{ TypeName }}>
    {
        /// <summary>
        /// A read-only instance of the {{ TypeName }} whose value is all zeros.
        /// </summary>
        public static readonly {{ TypeName }} Empty;

        static {{ TypeName }}()
        {
            {{ TypeName }}.Empty = new {{ TypeName}}(byte.MinValue);
            {{~ if ConverterAttributes[4] == true ~}}
            SqlMapper.AddTypeHandler(new {{ TypeName}}DapperTypeHandler());
            {{~ end ~}}
        }

        public static {{ TypeName }} New(byte? Value = null) => new(Value ?? byte.MinValue);

        /// <summary>Parses a span of characters into a value.</summary>
        /// <param name="s">The span of characters to parse.</param>
        /// <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="NumberStyles.Integer"/>.</param>
        /// <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        /// <returns>The result of parsing <paramref name="s" />.</returns>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException"><paramref name="s" /> is not representable by <see name="{{ TypeName }}" />.</exception>
        public static {{ TypeName }} Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null)
        {
            var parsedValue = byte.Parse(s, style, provider);
            return new(parsedValue);
        }

        /// <summary>Parses a string into a value.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="NumberStyles.Integer"/>.</param>
        /// <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        /// <returns>The result of parsing <paramref name="s" />.</returns>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException"><paramref name="s" /> is not representable by <see name="{{ TypeName }}" />.</exception>
        public static {{ TypeName }} Parse(string s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null) =>
            Parse(s != null ? (ReadOnlySpan<char>)s : throw new ArgumentNullException(nameof(s)), style, provider);

        /// <summary>Tries to parses a span of characters into a value.</summary>
        /// <param name="s">The span of characters to parse.</param>
        /// <param name="result">On return, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        /// <returns><see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(ReadOnlySpan<char> s, out {{ TypeName }} result) =>
            TryParse(s, NumberStyles.Integer, NumberFormatInfo.CurrentInfo, out result);

        /// <summary>Tries to parses a span of characters into a value.</summary>
        /// <param name="s">The span of characters to parse.</param>
        /// <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="NumberStyles.Integer"/>.</param>
        /// <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        /// <param name="result">On return, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        /// <returns><see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out {{ TypeName }} result)
        {
            if (byte.TryParse(s, style, provider, out var parsedValue))
            {
                result = new(parsedValue);
                return true;
            }
            else
            {
                result = Empty;
                return false;
            }
        }

        /// <summary>Tries to parse a string into a value.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="result">On return, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        /// <returns><see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(string s, out {{ TypeName }} result) =>
            TryParse(s, NumberStyles.Integer, NumberFormatInfo.CurrentInfo, out result);

        /// <summary>Tries to parse a string into a value.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="NumberStyles.Integer"/>.</param>
        /// <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        /// <param name="result">On return, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        /// <returns><see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(string s, NumberStyles style, IFormatProvider? provider, out {{ TypeName }} result) =>
            TryParse(s != null ? (ReadOnlySpan<char>)s : throw new ArgumentNullException(nameof(s)), style, provider, out result);

        /// <summary>
        /// Gets the value of the {{ TypeName }}.
        /// </summary>
        public byte Value { readonly get; init; }

        /// <summary>
        /// Initializes a new instance of the {{ TypeName }} using the 
        /// value represented by the specified integer.
        /// </summary>
        public {{ TypeName }}(byte Value)
        {
            this.Value = Value;
        }

        public void Deconstruct(out byte Value)
        {
            Value = this.Value;
        }

        /// <inheritdoc />
        public int CompareTo(object? other)
        {
            if (other == null)
            {
                return 1;
            }

            if (other is {{ TypeName }} t)
            {
                return this.CompareTo(t);
            }

            throw new ArgumentException("The object is not the same type as this instance.", nameof(other));
        }

        /// <inheritdoc />
        public int CompareTo({{ TypeName }} other) => Value.CompareTo(other.Value);

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            return (!(obj is {{ TypeName }}) ? false : this.Equals(({{ TypeName }})obj));
        }

        /// <inheritdoc />
        public bool Equals({{ TypeName }} other)
        {
            return EqualityComparer<byte>.Default.Equals(this.Value, other.Value);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            return EqualityComparer<byte>.Default.GetHashCode(this.Value);
        }

        public static bool operator ==({{ TypeName }} left, {{ TypeName }} right)
        {
            return left.Equals(right);
        }

        public static bool operator !=({{ TypeName }} left, {{ TypeName }} right)
        {
            return !(left == right);
        }

        private bool PrintMembers(StringBuilder builder)
        {
            builder.Append("Value = ");
            builder.Append(this.Value.ToString());
            return true;
        }

        private string ToDebugString()
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append("{{ TypeName }}");
            stringBuilder.Append(" { ");
            if (this.PrintMembers(stringBuilder))
            {
                stringBuilder.Append(' ');
            }
            stringBuilder.Append('}');
            return stringBuilder.ToString();
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return this.Value.ToString();
        }
    }
}