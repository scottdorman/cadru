//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Cadru.StronglyTypedId source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
{{ if NullableEnabled }}#nullable restore{{ end }}

using System;
using System.Globalization;
using System.Text;
{{ for usingDirective in UsingDirectives ~}}
using {{ usingDirective }};
{{ end ~}}

namespace {{ ContainingNamespace }}
{
    /// <inheritdoc />
    [System.CodeDom.Compiler.GeneratedCode("Cadru.StronglyTypedId", "{{ AssemblyVersion }}")]
    [System.Diagnostics.DebuggerDisplay("{ToDebugString()}")]
    {{~ if ConverterAttributes[0] == true ~}}
    [System.ComponentModel.TypeConverter(typeof({{ TypeName }}TypeConverter))]
    {{~ end ~}}
    {{~ if ConverterAttributes[1] == true ~}}
    [Newtonsoft.Json.JsonConverter(typeof({{ TypeName }}NewtonsoftJsonConverter))]
    {{~ end ~}}
    {{~ if ConverterAttributes[2] == true ~}}
    [System.Text.Json.Serialization.JsonConverter(typeof({{ TypeName }}JsonConverter))]
    {{~ end ~}}
    {{ if IsRecordStruct }}readonly partial record struct{{ else }}partial record class{{ end }} {{ TypeName }}(string Value) : IComparable, IComparable<{{ TypeName }}>
    {
        /// <summary>
        /// A read-only instance of the {{ TypeName }} whose value is <see cref="String.Empty"/>.
        /// </summary>
        public static readonly {{ TypeName }} Empty;

        static {{ TypeName }}()
        {
            {{ TypeName }}.Empty = new {{ TypeName}}(string.Empty);
            {{~ if ConverterAttributes[4] == true ~}}
            SqlMapper.AddTypeHandler(new {{ TypeName}}DapperTypeHandler());
            {{~ end ~}}
        }

        /// <summary>
        /// Initializes a new instance of the {{ TypeName }}
        /// </summary>
        public static {{ TypeName }} New(string Value) => new(Value);

        /// <summary>Parses a span of characters into a value.</summary>
        /// <param name="s">The span of characters to parse.</param>
        /// <returns>The result of parsing <paramref name="s" />.</returns>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException"><paramref name="s" /> is not representable by <see name="{{ TypeName }}" />.</exception>
        public static {{ TypeName }} Parse(ReadOnlySpan<char> s) =>
            new(s.ToString());

        /// <summary>Parses a string into a value.</summary>
        /// <param name="s">The string to parse.</param>
        /// <returns>The result of parsing <paramref name="s" />.</returns>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException"><paramref name="s" /> is not representable by <see name="{{ TypeName }}" />.</exception>
        public static {{ TypeName }} Parse(string s) =>
            Parse(s != null ? (ReadOnlySpan<char>)s : throw new ArgumentNullException(nameof(s)));

        /// <summary>Tries to parse a span of characters into a value.</summary>
        /// <param name="s">The span of characters to parse.</param>
        /// <param name="result">On return, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        /// <returns><see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(ReadOnlySpan<char> s, out {{ TypeName }} result)
        {
            result = new(s.ToString());
            return true;
        }

        /// <summary>Tries to parse a string into a value.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="result">On return, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        /// <returns><see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        public static bool TryParse(string s, out {{ TypeName }} result) =>
            TryParse(s != null ? (ReadOnlySpan<char>)s : throw new ArgumentNullException(nameof(s)), out result);

        public string Value { get; init; } = Value ?? throw new System.ArgumentNullException(nameof(Value));

        /// <inheritdoc />
        public int CompareTo(object? other)
        {
            if (other == null)
            {
                return 1;
            }

            if (other is {{ TypeName }} t)
            {
                return this.CompareTo(t);
            }

            throw new ArgumentException("The object is not the same type as this instance.", nameof(other));
        }

        /// <inheritdoc />
        public int CompareTo({{ TypeName }} other) => Value.CompareTo(other.Value);

        private string ToDebugString()
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append("{{ TypeName }}");
            stringBuilder.Append(" { ");
            if (this.PrintMembers(stringBuilder))
            {
                stringBuilder.Append(' ');
            }
            stringBuilder.Append('}');
            return stringBuilder.ToString();
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return this.Value;
        }
    }
}