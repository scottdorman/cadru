<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DownloadInfoConnectionClosed" xml:space="preserve">
    <value>Could not download {0} - FTP server closed the connection.</value>
  </data>
  <data name="DownloadInfoInvalidResponseReceived" xml:space="preserve">
    <value>Could not download {0} - a web page was returned from the web server.</value>
  </data>
  <data name="FileDownloaderCancelled" xml:space="preserve">
    <value>Download was cancelled.</value>
  </data>
  <data name="FileDownloaderDownloadLocation" xml:space="preserve">
    <value>Downloading file to {0}.</value>
  </data>
  <data name="Format_BadDatePattern" xml:space="preserve">
    <value>Could not determine the order of year, month, and date from '{0}'.</value>
  </data>
  <data name="Format_BadDateTime" xml:space="preserve">
    <value>String was not recognized as a valid DateTime.</value>
  </data>
  <data name="Format_BadDateTimeCalendar" xml:space="preserve">
    <value>The DateTime represented by the string is not supported in calendar {0}.</value>
  </data>
  <data name="Format_BadDayOfWeek" xml:space="preserve">
    <value>String was not recognized as a valid DateTime because the day of week was incorrect.</value>
  </data>
  <data name="Format_BadFormatSpecifier" xml:space="preserve">
    <value>Format specifier was invalid.</value>
  </data>
  <data name="Format_BadQuote" xml:space="preserve">
    <value>Cannot find a matching quote character for the character '{0}'.</value>
  </data>
  <data name="Format_DateOutOfRange" xml:space="preserve">
    <value>The DateTime represented by the string is out of range.</value>
  </data>
  <data name="Format_EmptyInputString" xml:space="preserve">
    <value>Input string was either empty or contained only white space.</value>
  </data>
  <data name="Format_ExtraJunkAtEnd" xml:space="preserve">
    <value>Additional non-parsable characters are at the end of the string.</value>
  </data>
  <data name="Format_NeedSingleChar" xml:space="preserve">
    <value>String must be exactly one character long.</value>
  </data>
  <data name="Format_RepeatDateTimePattern" xml:space="preserve">
    <value>DateTime pattern '{0}' appears more than once with different values.</value>
  </data>
  <data name="Format_TwoTimeZoneSpecifiers" xml:space="preserve">
    <value>The String being parsed cannot contain two TimeZone specifiers.</value>
  </data>
  <data name="Format_UnknowDateTimeWord" xml:space="preserve">
    <value>The string was not recognized as a valid DateTime. There is a unknown word starting at index {0}.</value>
  </data>
  <data name="ArgumentNull_String" xml:space="preserve">
    <value>String reference not set to an instance of a String.</value>
  </data>
  <data name="Format_InvalidLen" xml:space="preserve">
    <value>String was not of correct length.</value>
  </data>
  <data name="Format_InvalidString" xml:space="preserve">
    <value>Input string was not in a correct format.</value>
  </data>
  <data name="Argument_MustBeIsoDateTime" xml:space="preserve">
    <value>Argument must be an IsoDateTime.</value>
  </data>
  <data name="Argument_EnumIllegalVal" xml:space="preserve">
    <value>Illegal enum value: {0}.</value>
  </data>
  <data name="Argument_InvalidEnumValue" xml:space="preserve">
    <value>The value '{0}' is not valid for this usage of the type {1}.</value>
  </data>
  <data name="Argument_InvalidFlag" xml:space="preserve">
    <value>Value of flags is invalid.</value>
  </data>
  <data name="Argument_InvalidIndexValuesString" xml:space="preserve">
    <value>The starting index and ending index refer to the same location in the string.</value>
  </data>
  <data name="Argument_StartIndexGreaterThanEndIndexString" xml:space="preserve">
    <value>The starting index refers to a location in the string that is after the ending index.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexLessThanLength" xml:space="preserve">
    <value>Index must be less than the length of string.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexLessThanZero" xml:space="preserve">
    <value>Index must be non-negative.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexString" xml:space="preserve">
    <value>Index was out of range. Must be non-negative and less than the length of the string.</value>
  </data>
  <data name="InvalidCast_FromTo" xml:space="preserve">
    <value>Invalid cast from '{0}' to '{1}'.</value>
  </data>
  <data name="MDA_InvalidFormatForLocal" xml:space="preserve">
    <value>Cannot apply format "{0}" to the date "{1}" as the date is already in local time.</value>
  </data>
  <data name="MDA_InvalidFormatForUtc" xml:space="preserve">
    <value>Cannot apply format "{0}" to the date "{1}" as the date is already in universal time.</value>
  </data>
  <data name="Argument_StringZeroLength" xml:space="preserve">
    <value>String cannot be of zero length.</value>
  </data>
  <data name="Argument_NotSerializable" xml:space="preserve">
    <value>Argument passed in is not serializable.</value>
  </data>
  <data name="Argument_MustBeDateTime" xml:space="preserve">
    <value>Object must be of type DateTime.</value>
  </data>
  <data name="Argument_MustBeString" xml:space="preserve">
    <value>Object must be of type String.</value>
  </data>
  <data name="Argument_MustBeAttribute" xml:space="preserve">
    <value>Argument must be an Attribute or derived from an Attribute.</value>
  </data>
  <data name="Format_Dns_Bad_Ip_Address" xml:space="preserve">
    <value>An invalid IP address was specified.</value>
  </data>
  <data name="ApplicationExcpetion_UnableToDetermineInstallRoot" xml:space="preserve">
    <value>Unable to determine the install root path for the .NET Framework.</value>
  </data>
  <data name="ArgumentExceptionMustBeEnum" xml:space="preserve">
    <value>Type provided must be an Enum.</value>
  </data>
  <data name="ArgumentOutOfRange_Range" xml:space="preserve">
    <value>Valid values are between {0} and {1}.</value>
  </data>
  <data name="Arg_GuidArrayCtor" xml:space="preserve">
    <value>Byte array for GUID must be exactly {0} bytes long.</value>
  </data>
  <data name="Format_GuidBrace" xml:space="preserve">
    <value>Expected {0xdddddddd, etc}.</value>
  </data>
  <data name="Format_GuidBraceAfterLastNumber" xml:space="preserve">
    <value>Could not find a brace, or the length between the previous token and the brace was zero (i.e., '0x,'etc.).</value>
  </data>
  <data name="Format_GuidComma" xml:space="preserve">
    <value>Could not find a comma, or the length between the previous token and the comma was zero (i.e., '0x,'etc.).</value>
  </data>
  <data name="Format_GuidDashes" xml:space="preserve">
    <value>Dashes are in the wrong position for GUID parsing.</value>
  </data>
  <data name="Format_GuidEndBrace" xml:space="preserve">
    <value>Could not find the ending brace.</value>
  </data>
  <data name="Format_GuidHexPrefix" xml:space="preserve">
    <value>Expected hex 0x in '{0}'.</value>
  </data>
  <data name="Format_GuidInvalidChar" xml:space="preserve">
    <value>Guid string should only contain hexadecimal characters.</value>
  </data>
  <data name="Format_GuidInvLen" xml:space="preserve">
    <value>Guid should contain 32 digits with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).</value>
  </data>
  <data name="Format_GuidUnrecognized" xml:space="preserve">
    <value>Unrecognized Guid format.</value>
  </data>
  <data name="Arg_MustBeSequentialGuid" xml:space="preserve">
    <value>Object must be of type SequentialGuid.</value>
  </data>
  <data name="Format_InvalidGuidFormatSpecification" xml:space="preserve">
    <value>Format String can be only "D", "d", "N", "n", "P", "p", "B", "b", "X" or "x".</value>
  </data>
  <data name="ArgumentException_EmptyString" xml:space="preserve">
    <value>{0} cannot be an empty string.</value>
  </data>
  <data name="Argument_NullElement" xml:space="preserve">
    <value>{0} cannot contain a null (Nothing in Visual Basic) element.</value>
  </data>
  <data name="Assertion_CollectionFailure" xml:space="preserve">
    <value>Expected a collection containing &lt;0&gt; items but actual was &lt;{0}&gt; items.</value>
  </data>
  <data name="Assertion_GenericFailure" xml:space="preserve">
    <value>Expected &lt;{0}&gt; but actual was &lt;{1}&gt;.</value>
  </data>
  <data name="AssumptionException_EmptyMessage" xml:space="preserve">
    <value>Assumption failed.</value>
  </data>
  <data name="AssumptionException_Message" xml:space="preserve">
    <value>Assumption failed. {0}</value>
  </data>
  <data name="Arg_MustBeUnixTimestamp" xml:space="preserve">
    <value>Object must be of type UnixTimestamp.</value>
  </data>
  <data name="ArgumentOutOfRange_UnixTimestampBadYears" xml:space="preserve">
    <value>Years value must be between +/-10000.</value>
  </data>
  <data name="ArgumentOutOfRange_DateArithmetic" xml:space="preserve">
    <value>The added or subtracted value results in an un-representable DateTime.</value>
  </data>
  <data name="ArgumentOutOfRange_UnixTimestampBadMonths" xml:space="preserve">
    <value>Months value must be between +/-120000.</value>
  </data>
  <data name="ArgumentOutOfRange_UnixTimestampBadSeconds" xml:space="preserve">
    <value>Seconds must be between UnixTimestamp.MinValue.Seconds and UnixTimestamp.MaxValue.Seconds.</value>
  </data>
  <data name="ArgumentOutOfRange_Day" xml:space="preserve">
    <value>Day must be between 1 and {0} for month {1}.</value>
  </data>
  <data name="ArgumentOutOfRange_DayOfWeek" xml:space="preserve">
    <value>The DayOfWeek enumeration must be in the range 0 through 6.</value>
  </data>
  <data name="Argument_UnixTimestampIsInvalid" xml:space="preserve">
    <value>The supplied UnixTimestamp represents an invalid time.  For example, when the clock is adjusted forward, any time in the period that is skipped is invalid.</value>
  </data>
  <data name="Arg_UnixTimestampRange" xml:space="preserve">
    <value>Combination of arguments to the UnixTimestamp constructor is out of the legal range.</value>
  </data>
  <data name="RelativeDateFormatStringDaysAgo" xml:space="preserve">
    <value>{0} days ago</value>
  </data>
  <data name="RelativeDateFormatStringDaysFromNow" xml:space="preserve">
    <value>{0} days from now</value>
  </data>
  <data name="RelativeDateFormatStringDefault" xml:space="preserve">
    <value>{0:MMM d, yyyy}</value>
  </data>
  <data name="RelativeDateFormatStringToday" xml:space="preserve">
    <value>Today, {0:h':'mm' 'tt}</value>
  </data>
  <data name="RelativeDateFormatStringTomorrow" xml:space="preserve">
    <value>Tomorrow</value>
  </data>
  <data name="RelativeDateFormatStringYesterday" xml:space="preserve">
    <value>Yesterday</value>
  </data>
  <data name="RelativeTimeFormatStringDay" xml:space="preserve">
    <value>day</value>
  </data>
  <data name="RelativeTimeFormatStringDays" xml:space="preserve">
    <value>days</value>
  </data>
  <data name="RelativeTimeFormatStringFuture" xml:space="preserve">
    <value>{0} {1} from now</value>
  </data>
  <data name="RelativeTimeFormatStringHour" xml:space="preserve">
    <value>hour</value>
  </data>
  <data name="RelativeTimeFormatStringHours" xml:space="preserve">
    <value>hours</value>
  </data>
  <data name="RelativeTimeFormatStringMinute" xml:space="preserve">
    <value>minute</value>
  </data>
  <data name="RelativeTimeFormatStringMinutes" xml:space="preserve">
    <value>minutes</value>
  </data>
  <data name="RelativeTimeFormatStringMonth" xml:space="preserve">
    <value>month</value>
  </data>
  <data name="RelativeTimeFormatStringMonths" xml:space="preserve">
    <value>months</value>
  </data>
  <data name="RelativeTimeFormatStringPast" xml:space="preserve">
    <value>{0} {1} ago</value>
  </data>
  <data name="RelativeTimeFormatStringSecond" xml:space="preserve">
    <value>second</value>
  </data>
  <data name="RelativeTimeFormatStringSeconds" xml:space="preserve">
    <value>seconds</value>
  </data>
  <data name="RelativeTimeFormatStringYear" xml:space="preserve">
    <value>year</value>
  </data>
  <data name="RelativeTimeFormatStringYears" xml:space="preserve">
    <value>years</value>
  </data>
  <data name="Argument_StartIndexGreaterThanEndIndex" xml:space="preserve">
    <value>The starting index refers to a location that is after the ending index.</value>
  </data>
  <data name="ArgumentOutOfRange_RangeInclusive" xml:space="preserve">
    <value>Valid values are between {0} and {1}, inclusive.</value>
  </data>
  <data name="ArgumentOutOfRange_UpperBound" xml:space="preserve">
    <value>The upper bound must be greater than the lower bound .</value>
  </data>
  <data name="InvalidOperation_LocalizationFailed" xml:space="preserve">
    <value>Cannot retrieve property "{0}" because localization failed.  Type "{1}" is not public or does not contain a public static string property with the name "{2}".</value>
  </data>
  <data name="Arg_AmbiguousMatchException" xml:space="preserve">
    <value>Ambiguous match found.</value>
  </data>
<data name="Argument_InvalidOffLen" xml:space="preserve">
     <value>Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.</value>
   </data>
  <data name="Argument_AddingDuplicateWithKey" xml:space="preserve">
    <value>An item with the same key has already been added. Key: {0}</value>
  </data>
  <data name="ArgumentOutOfRange_Count" xml:space="preserve">
    <value>Count must be positive and count must refer to a location within the string/array/collection.</value>
  </data>
  <data name="ArgumentOutOfRange_Index" xml:space="preserve">
    <value>Index was out of range. Must be non-negative and less than the size of the collection.</value>
  </data>
  <data name="ArgumentOutOfRange_ListInsert" xml:space="preserve">
    <value>Index must be within the bounds of the List.</value>
  </data>
  <data name="ArgumentOutOfRange_NeedNonNegNum" xml:space="preserve">
    <value>Non-negative number required.</value>
  </data>
  <data name="Arg_ArrayPlusOffTooSmall" xml:space="preserve">
     <value>Destination array is not long enough to copy all the items in the collection. Check array index and length.</value>
   </data>
  <data name="Arg_HTCapacityOverflow" xml:space="preserve">
    <value>Capacity has overflowed.</value>
  </data>
  <data name="Arg_KeyNotFoundWithKey" xml:space="preserve">
    <value>The given key '{0}' was not present in the dictionary.</value>
  </data>
  <data name="CopyTo_ArgumentsTooSmall" xml:space="preserve">
    <value>Destination array is not long enough to copy all the items in the collection. Check array index and length.</value>
  </data>
  <data name="Create_TValueCollectionReadOnly" xml:space="preserve">
    <value>The specified TValueCollection creates collections that have IsReadOnly set to true by default. TValueCollection must be a mutable ICollection.</value>
  </data>
  <data name="InvalidOperation_ConcurrentOperationsNotSupported" xml:space="preserve">
    <value>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</value>
  </data>
  <data name="InvalidOperation_EnumEnded" xml:space="preserve">
    <value>Enumeration already finished.</value>
  </data>
  <data name="InvalidOperation_EnumFailedVersion" xml:space="preserve">
    <value>Collection was modified; enumeration operation may not execute.</value>
  </data>
  <data name="InvalidOperation_EnumNotStarted" xml:space="preserve">
    <value>Enumeration has not started. Call MoveNext.</value>
  </data>
  <data name="InvalidOperation_EnumOpCantHappen" xml:space="preserve">
    <value>Enumeration has either not started or has already finished.</value>
  </data>
  <data name="NotSupported_KeyCollectionSet" xml:space="preserve">
    <value>Mutating a key collection derived from a dictionary is not allowed.</value>
  </data>
  <data name="NotSupported_ValueCollectionSet" xml:space="preserve">
    <value>Mutating a value collection derived from a dictionary is not allowed.</value>
  </data>
  <data name="ReadOnly_Modification" xml:space="preserve">
    <value>The collection is read-only</value>
  </data>
</root>